### 先来一道面试题

**Synchronized和Lock有什么异同点，谁好谁坏，两者分别适合在什么时候使用？“这个问题应该还蛮高频”**

> 首先，说一个可惜的点，synchronized直接看源码，因为他是关键字级别的，要想看只能通过jdk源码看了，等有机会反编译一下吧，他应该是用C写的

| 类别     | Synchronized                                                 | Lock                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 存在层次 | 关键字，jvm层面内置特性                                      | 接口，通过实现类可实现同步访问                               |
| 锁的获取 | 无锁、偏向锁、轻量级锁、重量级锁等4个状态<br />整体是一个锁升级的过程，不可降级 | 获取锁、中断获取锁、尝试获取锁、尝试等待获取锁等方法         |
| 锁的释放 | 已获取锁的线程执行完同步代码后释放锁<br />线程执行发生异常后释放锁 | 必须在finally代码块中执行unLock()释放锁方法，否则容易造成死锁现象 |
| 锁的状态 | 无法判断                                                     | 可判断是否能获取到锁                                         |
| 锁的类型 | 可重入，不可中断，非公平，“悲观锁”                           | 可重入，可中断，可选择是否公平，“乐观锁”                     |
| 性能     | 适合少量同步，资源竞争不是很激烈的情况                       | 适合大量同步，资源竞争激烈的情况                             |
| 修饰类型 | 普通方法，锁的是当前实例对象<br />静态方法，锁的是当前类的class对象<br />方法块，锁的是括号里面的对象 | 只适用于代码块                                               |

### 再细说这两者

#### synchronized

#### 获取锁机制，锁升级

#### lock

##### 基础方法

| 方法名                                   | 含义                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| void lock()                              | 获得锁。                                                     |
| void lockInterruptibly()                 | 获取锁定，除非当前线程是 interrupted 。                      |
| Condition newCondition()                 | 返回一个新Condition绑定到该实例`Lock`实例。                  |
| boolean tryLock()                        | 只有在调用时才可以获得锁。                                   |
| boolean tryLock(long time,TimeUnit unit) | 如果在给定的等待时间内是空闲的，并且当前的线程尚未得到 interrupted则获取该锁。 |
| void unlock()                            | 释放锁。                                                     |

